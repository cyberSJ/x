/**
  * Things covered in this example:
  * - Compiling a third party c or java source code.
  * - Compiling a c source using CppCompile.
  * - Including another party's header file.
  * - Linking a third party's static library.
  * - Using the output java .class files in another java code.
  * - Getting a reference to a shared library build artifact.
  * - Passing arguments to the java compiler.
  * - Passing arguments to the JVM before run.
  * - Passing the classpath to the JVM when a program is run.
  * - building and running a jar.
  * - JNI basic.
  * - FFT basic.
  */
plugins {
    // Import the c++ library for building libjfftw.so.
    id 'cpp-library'

    // Import the java library for building the java code that uses JFFTW.
    id 'java'

    // Import in order to run the java program. This plugin introduces the
    // "gradle run" task.
    id 'application'
}

/**
 * @brief Path to the JFFTW code package. It contains the c and java sources.
 */
// TODO: Make this a local repo.
def jfftwDirPath = "/home/cyber/sandbag/jfftw-1.2"

/**
 * @brief Path to the JFFTW c code. JFFTW java code needs shared library from c
 * code.
 */
def jfftwCDirPath = "${jfftwDirPath}/c"

/**
 * @brief Path to the JFFTW java  code.
 */
def jfftwJavaDirPath = "${jfftwDirPath}/java"

/**
 * @brief Path to the FFTW C header files. JFFTW C code utilizes the FFTW C 
 *        code.
 */
def fftwIncludeDirPath = "/usr/local/include"

/**
 * @brief Path to the FFTW static libraries.
 */
def fftwLibraryDirPath = "/usr/local/lib"

/**
 * @brief Path to the Java home. Used as a parent of the directory containing 
 *        the JNI header files.
 */
def javaHomePath = "/usr/lib/jvm/default-java"

/**
 * @brief Path to the JNI header files.
 */
def jniHeaderDirPath = "${javaHomePath}/include"

/**
 * @brief Path to the JNI linux header files.
 */
def jniLinuxHeaderDirPath = "${jniHeaderDirPath}/linux"

/**
 * @brief The target name of the shared library produced by compiling the JFFTW
 *        c code.
 */
def libJfftwSharedLibraryName = "jfftw"

def libjfftwLibraryPathUnoptimized = ""

library {
    binaries.configureEach {
        // Tell gradle to find the path to the JFFTW c sources. We need to tell
        // gradle that we want to use ANY FILE with .c extension under the 
        // designated top directory umbrella.
        // FileTree extends FileCollection.
        // ** = Any directory.
        // * = Any file name.
        def jfftwCSources = fileTree("${jfftwCDirPath}")
        jfftwCSources.include "**/*.c"
        def cppCompile = compileTask.get()
        cppCompile.source.from jfftwCSources

        // Since JFFTW c sources needs the jni.h headers, include those headers
        // during the compilation of JFFTW c sources.
        def jniHeadersDir = file("${jniHeaderDirPath}")
        def jniLinuxHeaderDir = file("${jniLinuxHeaderDirPath}")
        cppCompile.includes.from jniHeadersDir
        cppCompile.includes.from jniLinuxHeaderDir

        // Tell the c++ compiler that we are compiling c sources. But why do I
        // have to do this? I thought GCC already understood c. Maybe the
        // Gradle's wrapper around c++ compiler only understnad c++ and not c.
        // TODO: I also saw that there is CCompiler in the gradle doc. Maybe use 
        // that.
        if (toolChain instanceof GccCompatibleToolChain) {
            cppCompile.compilerArgs = ["-x", "c", 
                                       "-std=c11"]
        }

        // Link the fftw C library to the libjfftw.so. Without these, some of
        // the functions in libjfftw.so are undefined.
        def linkSharedLibrary = linkTask.get()
        linkSharedLibrary.linkerArgs = 
            ["${fftwLibraryDirPath}/libfftw.a",
             "${fftwLibraryDirPath}/librfftw.a"]
        System.out.println("sung ________ linkSharedLibrary linkerArgs: " +
                linkSharedLibrary.linkerArgs);

        // When the program runs, let the JVM know where to find the 
        // libjfftw.so. The libjfftw.so is the product of this C++ library.
        // applicationDefaultJvmArgs comes from the java plugin (it is not a
        // member variable in CppBinary).
        def outputDirSpecifier = ""
        outputs.forEach{
            def outputDir = it.getParentFile()
            outputDirSpecifier += File.pathSeparator + outputDir
        }
        applicationDefaultJvmArgs += ["-Djava.library.path=" +
                                      outputDirSpecifier]
        
        System.out.println("sung ________ : " + targetPlatform) 
    }

    // Change the name of the generated shared library to "libjfftw.so" because 
    // the JFFTW Java code is harde coded to reference such library.
    baseName = libJfftwSharedLibraryName 
}

sourceSets {
    // Declaring "jfftw" creates a jfftw SourceSet. Create this custom sourceSet
    // in order to logically separate the third-party jfftw java code and my 
    // code living under the src/main/java.
    jfftw {
        // SourceSet has an explicit method called "java("
        java {
            // Specify the source directory containing the JFFTW java sources.
            // These java sources will be compiled and their class files will
            // reside in the build directory so that my main sourceSet can use
            // it.
            srcDir "${jfftwJavaDirPath}"
        }
    }

    // Tell main to depend on the jfftw sourceSet's output class.
    main {
        // Using sourceSet.output allows for the "incremental build" to happen.
        // This means "main" sourceSet will automatically declare dependency on 
        // the "jfftw" sourceSet, and "main" will be built AFTER "jfftw" is
        // build.
        def jfftwOutputDir = sourceSets.jfftw.output

        // compileClasspath is a FileCollection. You can use += operator to
        // append to the collection in addtion to the default src/main/java 
        // path. This allows my custom java code to import the jfftw java code.
        compileClasspath += jfftwOutputDir 
    }
}

tasks.withType(JavaCompile) {
    // JFFTW uses some deprecated java functions, and java wants to explicitly
    // generate warnings about using depreceated functions. So this compilation 
    // option is used to tell the java compiler that it can generate warnings 
    // about it.
    options.compilerArgs += "-Xlint:deprecation"
}

// Specify the java class that contains the main function.
mainClassName = "JavaFft"

// Add the jfftw output classpath to the main's classpath when running (as
// opposed to compiling) the main code.
dependencies {
    runtimeOnly files(sourceSets.jfftw.output)
}

// When the program runs, let the JVM know where to find the libjfftw.so.
//println ("sung lib path: " + library.developmentBinary.get().outputs.asList())
//println "sung final libjfftwLibraryPathUnoptimized: " + libjfftwLibraryPathUnoptimized
//applicationDefaultJvmArgs += ["-Djava.library.path=" +
//                             libjfftwLibraryPathUnoptimized]
